module HW2 where
{-

=== 연산자 ===

기본 문법 요소임에도 수업 시간에 제대로 설명해주지 못했기에 언급합니다.

연산자, 즉:
  * 특수문자(들)로만 이루어진 이항 중위 연산자들,
  * 이항 이상의 함수의 이름을 backquote(`)로 감싼 것들, 그리고
  * Haskell의 유일한 단항 전위 연산자인 음수 부호 -
와 그 피연산자 사이에는 공백이 있어도 되고 없어도 됩니다. 예를 들어:
    3+5
도 맞고
    3 + 5
도 맞습니다. 단, 연산자와 피연산자 사이의 공백은 juxtapositioning이 아니며,
justapositioning보다 결합 강도가 약합니다. 따라서,
    f 3 + f 5
는 "(f 3) + (f 5)"로 해석됩니다.

이에 관해 가장 조심해야할 때가 함수의 인자 속에 연산자가 들어있는 경우입니다.
예를 들어:
    f x + 1
는 "(f x) + 1"로 해석됩니다.
즉, "f x"부터 먼저 계산한 후, 그 결과에 1을 더합니다.
위와 같이 띄어서 쓰면 그나마 덜 헛갈리는데, 붙여서 쓰면 좀 더 헛갈립니다:
    f x+1
이렇게 붙여서 쓰면 얼핏 "x+1"이 한 덩어리처럼 보여서 먼저 계산될 것 같지만,
소용 없습니다. 이렇게 써도 마찬가지로 "(f x)+1"로 해석됩니다.
만일 의도했던 것이 "x + 1"부터 먼저 계산해서
그 결과를 함수 f에 인자로 넣어주고 싶었던 것이라면, 명시적으로 괄호를 쳐서
    f (x + 1)
이라고 해야합니다.


=== 섹션 ===

수업 시간에 이미 설명했던 사항이지만, 다시 정리합니다.

이항 중위 연산자의 두 피연산자들 중 일부를 빼고 괄호로 묶은 것을
섹션(section)이라고 합니다. 예를 들어 (+ 3)이나 (3 +), (+) 같은 것들입니다.
이런 섹션들은 "인자를 받아서 그 인자를 부족한(비어있는) 피연산자 자리에
채워넣은 결과를 계산하는 함수"입니다. 예를 들어:
    (+ 3)    =  (\x -> x + 3)

    (+ 3) 5  =  (\x -> x + 3) 5
             =         5 + 3

    (3 +)    =  (\x -> 3 + x)

    (3 +) 5  =  (\x -> 3 + x) 5
             =         3 + 5

두 피연산자들이 모두 비어있으면 왼쪽 피연산자부터 먼저 채워집니다.
(첫번째 인자가 왼쪽, 두번째 인자가 오른쪽 피연산자 자리에 들어갑니다.)
예를 들어:
    (+)      =   (\x y -> x + y)
             =   (\x -> \y -> x + y)
             =   (\x -> (\y -> x + y))

    (+) 3 5  =  (      (+)             3) 5
             =  ((\x -> (\y -> x + y)) 3) 5
             =          (\y -> 3 + y)     5
             =                 3 + 5

단, 뺄셈을 뜻하는 이항 중위 연산자 - 만큼은 예외적으로
(여전히 (-) 형태나 (3 -) 형태의 섹션은 가능해도)
(- 3) 형태의 섹션은 불가능합니다.
"-" 기호는 음수 부호를 뜻하는 단항 전위 연산자로도 쓰이기 때문이며,
"인자에서 3을 빼는 함수"를 만들려면 섹션이 아니라
subtract 함수를 이용해서 (subtract 3) 이라고 써야합니다.


=== 함수 합성, 제곱 연산자 ===

두 함수를 합성하는 이항 중위 연산자는 . 입니다.
    (.) :: (b -> c) -> (a -> b) -> a -> c
즉, f와 g가 함수고, x가 g의 정의역의 원소고,
g의 공변역이 f의 정의역과 같을 때, 항상:
    (f . g) x  =  f (g x)
라는 등식이 성립합니다.

b의 e승을 계산하는 이항 중위 연산자는 두 가지로서 ^와 **이 있는데,
서로 타입이 다릅니다:
    (^)  :: (Integral b, Num a) => a -> b -> a
    (**) :: Floating a => a -> a -> a
^는 좌측 피연산자(밑)는 아무 수(Num 클래스 소속의 아무 타입)나 가능하지만
    우측 피연산자(지수)는 반드시 정수(Int 혹은 Integer 타입)여야 합니다.
    대신, 계산 결과는 항상 밑과 같은 타입이므로 밑이 정수면 결과도 정수입니다.
**는 두 피연산자가 모두 부동소수점수(Float 혹은 Double)여야 하고
    결과도 항상 부동소수점수입니다.

타입 클래스가 (특히 수치형을 다룰 때) 자꾸 등장하는 것이 혼동을 줄 수 있기에,
(아직 타입 선언도 설명하기 전이지만) 타입 클래스에 대해 다음 수업 때
먼저 간단히 (혼동을 없앨 만큼만) 설명하겠습니다.

이 숙제에서는 깔끔한 (근사치가 아닌) 정수 연산을 위해서
제곱 연산자로 ^를 사용하겠습니다.



=== 중간고사 11-c ===

이제 중간고사 11-c번 문제를 보겠습니다.
먼저, 가장 권장되는, 제정신인 (sane) 정의 방법은 당연히 다음과 같습니다:
-}
fooSane :: Integer -> Integer
fooSane b = b ^ 3 + 100  -- 평소에는 특별한 이유가 없다면 이렇게 정의하셔요
                         -- 참고: ^가 +보다 결합 강도가 강해서 먼저 묶입니다

-- 굳이 매개변수 대신 lambda 구문을 쓰면 다음과 같고:
fooLambda:: Integer -> Integer
fooLambda = \b -> b ^ 3 + 100   

-- 문제지 1페이지에 정의되어있던 add와 exp를 각각 다음과 같이 정의한 후
-- (참고: exp라는 이름은 Haskell에 이미 다른 의미로 정의되어 있어서:
--                exp x = e ** x    (단, e는 자연대수)
-- 여기서는 exp대신 expo라는 이름을 사용했습니다):
add, expo :: Integer -> Integer -> Integer
add x y = x + y
expo x y = x ^ y

-- 이들을 이용해서 문제지 11-c번에 주어진 식 "λb.add (exp b c3) c100"을
-- 그대로 따라하면 다음과 같습니다:
fooLambdaNoInfix :: Integer -> Integer
fooLambdaNoInfix = \b -> add (expo b 3) 100

-- 당연히, add, expo 대신 람다 텀을 직접 쓸 수도 있습니다:
fooLambdaOnly :: Integer -> Integer
fooLambdaOnly = \b -> (\x y -> x + y) ((\x y -> x ^ y) b 3) 100

-- 혹은, add, expo 대신 각각 "양쪽이 빈" 섹션을 사용하면 다음과 같고:
fooLambdaSect :: Integer -> Integer
fooLambdaSect = \b -> (+) ((^) b 3) 100

-- 이제 lambda 구문 없이 함수 합성과 flip을 이용해서 정의하면
-- 다음과 같습니다:
fooSectOnly :: Integer -> Integer
fooSectOnly = (.) (flip (+) 100) (flip (^) 3)
-- 참고: 중간고사 정답지에 (+) 즉 add 쪽에 flip이 없는데,
--                   (.) ((+) 100) (flip (^) 3)
-- 엄밀히 말하자면 정답지가 부정확하고 위 정의가 정확합니다.
-- (100은 +의 오른쪽 피연산자여야 하기 때문입니다.)


{-
=== 숙제 문제 ===

자, 이제 문제입니다. 아래 159행과 160행의 맨 앞 주석을 풀고
fooShort 함수를 정의하되:
    * 매개변수도, lambda 구문도 일체 사용하지 말고,
    * 괄호는 최대 두 쌍까지만 사용해서,
    * 가능한 한 "짧게" ('공백이 아닌 문자'의 갯수가 적게) 정의해보십시오.
힌트: 중위 연산자들은 양쪽이 빈 섹션 형태 외에 한쪽만 빈 섹션이나
      그냥 평범한 중위 형태로 사용하는 게 더 유리할 수도 있고,
      flip은 꼭 필요할 때만 쓰고 불필요하면 안 쓰는 게 더
      유리할 수도 있습니다.
-}
fooShort :: Integer -> Integer
fooShort = (+100).(^3)


{-
다시 한 번 강조하지만,
평상시에 항상 이 방식(섹션)으로 정의하라는 의미가 아니라
이 방식이 유용한 경우가 종종 있으니
그럴 때 사용할 수 있도록 훈련하라는 의미입니다.

유용한 경우의 실제 예는 강의자료 코드 #1 중 Primes.hs 파일의
9행과 11행을 참조하기 바랍니다.
(이 파일은 수업 시간에 진행할 예정입니다.)
-}